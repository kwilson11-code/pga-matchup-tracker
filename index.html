<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PGA Matchup Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; }
        h1 { text-align: center; color: #004d00; }
        #search { width: 100%; max-width: 600px; padding: 12px; margin: 20px auto; display: block; font-size: 16px; border: 1px solid #ccc; border-radius: 4px; }
        #status { text-align: center; font-weight: bold; margin: 20px; font-size: 18px; }
        .error { color: red; }
        .group { background: white; border: 1px solid #ddd; padding: 15px; margin: 15px auto; max-width: 700px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .favorite { border-color: #ffd700; background: #fffacd; }
        .star { cursor: pointer; font-size: 24px; float: right; color: #ffcc00; }
        .player { margin: 10px 0; font-size: 16px; padding: 5px; border-radius: 4px; }
        .winner { font-weight: bold; color: #006400; background: #e0ffe0; }
    </style>
</head>
<body>
    <h1>PGA 3-Ball/2-Ball Matchup Tracker</h1>
    <input type="text" id="search" placeholder="Search by player name or tee time (e.g., Hisatsune, 07:30)...">
    <div id="status">Loading live leaderboard...</div>
    <div id="favorites"></div>
    <div id="all-groups"></div>

    <script>
    const PGA_FEED = 'https://statdata.pgatour.com/r/current/leaderboard-v2mini.json';

    let allGroups = [];
    let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');

 async function fetchLeaderboard() {
    const proxy = 'https://corsproxy.io/?';
    const url = proxy + encodeURIComponent('https://statdata.pgatour.com/r/current/leaderboard-v2mini.json');
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
    const data = await response.json();
    console.log('PGA data via proxy:', data);
    return data.leaderboard?.players || [];
}

    function groupByTeeTime(players) {
        const groups = {};
        players.forEach(player => {
            const teeTime = player.tee_time || 'Unknown';
            if (!groups[teeTime]) groups[teeTime] = [];
            groups[teeTime].push(player);
        });
        return Object.entries(groups).map(([teeTime, players]) => ({ teeTime, players }));
    }

    function determineWinner(players) {
        let minScore = Infinity;
        let winner = null;
        players.forEach(p => {
            const score = parseInt(p.total) || 0; // relative to par, e.g. -6
            if (score < minScore) {
                minScore = score;
                winner = p.player_name;
            }
        });
        return winner;
    }

    function renderGroups(groups, containerId, isFavorites = false) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        groups.forEach(group => {
            const div = document.createElement('div');
            div.classList.add('group');
            if (favorites.includes(group.teeTime)) div.classList.add('favorite');

            const star = document.createElement('span');
            star.classList.add('star');
            star.textContent = favorites.includes(group.teeTime) ? '★' : '☆';
            star.onclick = () => toggleFavorite(group.teeTime);

            const header = document.createElement('h3');
            header.textContent = `${group.teeTime} Group (${group.players.length}-ball)`;
            header.appendChild(star);

            div.appendChild(header);

            const winner = determineWinner(group.players);
            group.players.forEach(player => {
                const pDiv = document.createElement('div');
                pDiv.classList.add('player');
                const score = player.total || 'E';
                const thru = player.thru || 0;
                pDiv.textContent = `${player.player_name}: ${score} (through ${thru} holes)`;
                if (player.player_name === winner) pDiv.classList.add('winner');
                div.appendChild(pDiv);
            });

            container.appendChild(div);
        });
    }

    function toggleFavorite(teeTime) {
        const index = favorites.indexOf(teeTime);
        if (index > -1) favorites.splice(index, 1);
        else favorites.push(teeTime);
        localStorage.setItem('favorites', JSON.stringify(favorites));
        loadData();
    }

    function filterGroups(query) {
        return allGroups.filter(group => 
            group.teeTime.toLowerCase().includes(query.toLowerCase()) ||
            group.players.some(p => p.player_name.toLowerCase().includes(query.toLowerCase()))
        );
    }

    async function loadData() {
        const status = document.getElementById('status');
        status.textContent = 'Loading live PGA data...';
        status.classList.remove('error');
        try {
            const players = await fetchLeaderboard();
            if (players.length === 0) throw new Error('No players returned');
            allGroups = groupByTeeTime(players);

            renderGroups(allGroups.filter(g => favorites.includes(g.teeTime)), 'favorites', true);

            const searchQuery = document.getElementById('search').value;
            const filtered = searchQuery ? filterGroups(searchQuery) : allGroups;
            renderGroups(filtered, 'all-groups');

            status.textContent = `Loaded ${players.length} players!`;
        } catch (error) {
            console.error('Error:', error);
            status.textContent = `Error: ${error.message}. Check console (F12).`;
            status.classList.add('error');
        }
    }

    document.getElementById('search').addEventListener('input', loadData);
    loadData();
    setInterval(loadData, 60000);
</script>
</body>
</html>
